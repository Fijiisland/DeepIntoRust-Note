# 表达式

> Rust is primarily an expression language -- Rust Reference

expression在Rust中十分重要，且Rust中的表达式具有“一致性”，每个表达式都可嵌套在另一个表达式中，组成一个新的表达式。

Rust的表达式包括字面量表达式分多钟，其可被分为左值(lvalue)与右值(rvalue)表达式。lvalue expression是指表达式可以表达一个内存地址，因此可被放到等号左边；否则表达式均属于rvalue expression。

***

### 3.2.1 运算表达式

类似`x + y`和`x * y`的为运算表达式。

Rust的比较运算符有 == ; != ; < ; > ; <= ; >=

*‌*比较运算符两边必须是同类型，并实现了PartialEq trait**，另外，Rust禁止连续比较：`a == b == c`

Rust的位运算符：

- ！ 按位取反
- & 按位与
- | 按位或
- ^ 按位异或
- << 左移
- >> 右移

Rust的逻辑运算符：

- && 逻辑与
- || 逻辑或
- ！逻辑取反

**注意逻辑取反和按位取反的操作符相同，若操作对象为bool类型则为逻辑取反，否则为按位取反。**

***

### 3.2.2 赋值表达式

`let mut x: i32 = 1;`

`x = 2; // x为mut绑定，可重新赋值。`

Rust规定赋值表达式的类型为()，这么设计的原因是防止连续赋值：`z = y = x; // 不允许`

***

### 3.2.3 语句块表达式

语句块也可作表达式的一部分。语句和表达式的区别：

- 语句： 带分号，类型为()
- 表达式：不带分号

```rust
let x: () = { println!("hello"); };

// Rust按顺序执行语句块中的语句，最后一个为表达式的话则将其返回，这里返回5
let y: i32 = { println!("hello"); 5 };
```

函数也利用了示例的特性：

```rust
fn my_func() -> i32 {
	...
	10 + 10 // 无分号
}
```

由于最后一条语句无分号，因此整个语句块的类型变为i32。